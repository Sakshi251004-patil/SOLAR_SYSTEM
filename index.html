<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System â€“ Sakshi Patil</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
      color: white;
    }
    canvas { display: block; }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
      max-height: 90vh;
      overflow-y: auto;
    }

    #pauseBtn, #musicBtn {
      position: absolute;
      background: #222;
      color: white;
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 10;
    }

    #pauseBtn { top: 10px; right: 10px; }
    #musicBtn { top: 50px; right: 10px; }

    #tooltip {
      position: absolute;
      padding: 5px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 20;
      display: none;
    }

    label {
      display: block;
      margin-top: 8px;
    }

    input[type="range"] {
      width: 150px;
    }
  </style>
</head>
<body>

<div id="controls"></div>
<button id="pauseBtn">Pause</button>
<button id="musicBtn">Play Music</button>
<div id="tooltip"></div>

<!-- âœ… Final Working Space Ambient Music -->
<audio id="bgMusic" loop>
  <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
</audio>

<!-- âœ… Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
camera.position.z = 30;

const light = new THREE.PointLight(0xffffff, 2, 300);
scene.add(light);

const sun = new THREE.Mesh(
  new THREE.SphereGeometry(2, 32, 32),
  new THREE.MeshBasicMaterial({ color: 0xffff00 })
);
scene.add(sun);

const planetsData = [
  { name: "Mercury", size: 0.3, dist: 4, speed: 0.04, color: 0xaaaaaa },
  { name: "Venus", size: 0.6, dist: 6, speed: 0.035, color: 0xffcc66 },
  { name: "Earth", size: 0.65, dist: 8, speed: 0.03, color: 0x3366ff },
  { name: "Mars", size: 0.5, dist: 10, speed: 0.027, color: 0xff3300 },
  { name: "Jupiter", size: 1.1, dist: 13, speed: 0.02, color: 0xff9966 },
  { name: "Saturn", size: 0.95, dist: 16, speed: 0.015, color: 0xffcc99 },
  { name: "Uranus", size: 0.8, dist: 19, speed: 0.012, color: 0x66ffff },
  { name: "Neptune", size: 0.8, dist: 22, speed: 0.01, color: 0x3366cc }
];

const planetMeshes = [];
const orbitAngles = [];
const controlsDiv = document.getElementById("controls");
const tooltip = document.getElementById("tooltip");
const bgMusic = document.getElementById("bgMusic");

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

planetsData.forEach((planet, i) => {
  const geo = new THREE.SphereGeometry(planet.size, 32, 32);
  const mat = new THREE.MeshStandardMaterial({ color: planet.color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.name = planet.name;
  scene.add(mesh);
  planetMeshes.push(mesh);
  orbitAngles.push(0);

  const label = document.createElement("label");
  label.textContent = `${planet.name} Speed`;
  const input = document.createElement("input");
  input.type = "range";
  input.min = 0.001;
  input.max = 0.1;
  input.step = 0.001;
  input.value = planet.speed;
  input.oninput = (e) => {
    planet.speed = parseFloat(e.target.value);
  };
  controlsDiv.appendChild(label);
  controlsDiv.appendChild(input);

  const ringGeo = new THREE.RingGeometry(planet.dist - 0.05, planet.dist + 0.05, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.rotation.x = Math.PI / 2;
  scene.add(ring);
});

// Background stars
const starGeo = new THREE.BufferGeometry();
const starCount = 1000;
const starPos = [];
for (let i = 0; i < starCount; i++) {
  starPos.push((Math.random() - 0.5) * 2000);
  starPos.push((Math.random() - 0.5) * 2000);
  starPos.push((Math.random() - 0.5) * 2000);
}
starGeo.setAttribute("position", new THREE.Float32BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({ color: 0xffffff });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

// Pause/Resume animation
let isPaused = false;
document.getElementById("pauseBtn").onclick = () => {
  isPaused = !isPaused;
  document.getElementById("pauseBtn").textContent = isPaused ? "Resume" : "Pause";
};

// Music button logic
document.getElementById("musicBtn").addEventListener("click", () => {
  bgMusic.volume = 0.5;
  bgMusic.play().then(() => {
    console.log("ðŸŽµ Music is playing");
  }).catch(err => {
    console.warn("Autoplay blocked â€” click again.");
    alert("Click again. Browser may block autoplay.");
  });
});

// Camera zoom on planet click
window.addEventListener("click", (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(planetMeshes);
  if (intersects.length > 0) {
    const planet = intersects[0].object;
    const target = new THREE.Vector3().copy(planet.position).add(new THREE.Vector3(0, 2, 5));
    camera.position.lerp(target, 0.2);
  } else {
    camera.position.set(0, 0, 30);
  }
});

// Tooltip on hover
window.addEventListener("mousemove", (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});

function animate() {
  requestAnimationFrame(animate);

  if (!isPaused) {
    planetsData.forEach((planet, i) => {
      orbitAngles[i] += planet.speed;
      planetMeshes[i].position.x = planet.dist * Math.cos(orbitAngles[i]);
      planetMeshes[i].position.z = planet.dist * Math.sin(orbitAngles[i]);
    });
  }

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(planetMeshes);

  if (intersects.length > 0) {
    tooltip.style.display = "block";
    tooltip.textContent = intersects[0].object.name;
    tooltip.style.left = `${event.clientX + 10}px`;
    tooltip.style.top = `${event.clientY + 10}px`;
  } else {
    tooltip.style.display = "none";
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
